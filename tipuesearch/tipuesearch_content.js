var tipuesearch = {"pages":[{"title":" lom ","text":"lom Description Example algorithm for low-lunar orbit maintenance. Status Building The program can be built and with the Fortran Package Manager using the provided fpm.toml file like so: fpm run -- configs/quick.json Where the command line argument is the config file that sets the run settings. See the files in the configs directory for examples. The program has the following dependencies which are automatically downloaded by FPM:\n* Fortran Astrodynamics Toolkit -- For basic orbital mechanics computations.\n* ddeabm -- For numerical propagation of the trajectory.\n* pyplot-fortran -- For plotting of the results.\n* json-fortran -- For reading the JSON config input file.\n* argv-fortran -- For getting command line arguments. Documentation The latest API documentation for the master branch can be found here . This is generated by processing the source files with FORD . License This code is released under a BSD-3 license . See also Low Lunar Orbit Maintenance [degenerateconic.com] May 06, 2018 Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"main.f90 – lom","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~altitude_maintenance.f90 altitude_maintenance.f90 sourcefile~main.f90->sourcefile~altitude_maintenance.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs main Source Code main.f90 Source Code !***************************************************************************************** !> !  Altitude maintenance test program program main use altitude_maintenance_module , only : segment use fortran_astrodynamics_toolkit , only : km2m use pyplot_module , only : pyplot use iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none ! run variables, populated by the config file: real ( wp ) :: dt_max !! how long to propagate (days) real ( wp ) :: et0 !! initial ephemeris time (sec) !! (only matters if including Earth/Sun perturbations) real ( wp ) :: tru0 !! initial true anomaly (deg) real ( wp ) :: alt0 !! initial altitude for circular orbit (km) real ( wp ) :: deadband_alt !! altitude below initial to trigger periapsis raise (km) real ( wp ) :: inc_start !! inc/lan grid real ( wp ) :: inc_stop real ( wp ) :: inc_step real ( wp ) :: lan_start real ( wp ) :: lan_stop real ( wp ) :: lan_step integer :: grav_n !! max grav degree integer :: grav_m !! max grav order character ( len = :), allocatable :: ephemeris_file !! earth/moon/sun ephemeris file character ( len = :), allocatable :: gravfile !! moon spherical harmonics gravity file real ( wp ), dimension (:), allocatable :: x !! x array for plot (raan) real ( wp ), dimension (:), allocatable :: y !! y array for plot (inc) real ( wp ), dimension (:,:), allocatable :: z !! z array for plot (dv) real ( wp ) :: inc0 !! initial inclination - IAU_MOON of date (deg) real ( wp ) :: ran0 !! initial RAAN - IAU_MOON of date (deg) integer :: n_dvs !! number of DV maneuvers performed real ( wp ) :: dv_total !! total DV (km/s) real ( wp ), dimension ( 6 ) :: xf !! final state - inertial frame (km, km/s) integer :: i_inc !! inclination counter integer :: i_raan !! raan counter type ( pyplot ) :: plt !! pyplot handler integer :: istat !! pyplot status code character ( len = 10 ) :: istr !! for integer to string conversion character ( len = 10 ) :: dt_max_str character ( len = 10 ) :: deadband_alt_str type ( segment ) :: seg !! the integrator for a ballistic moon-centered trajectory ! populate the run variables: call read_config_file () ! initialize the segment: call seg % initialize_seg ( alt0 , deadband_alt , grav_n , grav_m , ephemeris_file , gravfile ) write ( dt_max_str , '(I10)' ) int ( dt_max ); dt_max_str = adjustl ( dt_max_str ) write ( deadband_alt_str , '(I10)' ) int ( deadband_alt ); deadband_alt_str = adjustl ( deadband_alt_str ) call plt % initialize ( grid = . true ., xlabel = 'LAN (deg)' ,& ylabel = 'Inc (deg)' , figsize = [ 20 , 10 ],& title = 'Lunar Orbit Maintenance $\\Delta v$ (m/s) : deadband = ' // & trim ( deadband_alt_str ) // ' km : dt = ' // trim ( dt_max_str ) // ' days' ,& real_fmt = '(E9.3)' ) ! initialize the indep arrays: call size_arrays ( lan_start , lan_stop , lan_step , inc_start , inc_stop , inc_step , x , y , z ) do i_inc = 1 , size ( y ) inc0 = y ( i_inc ) ! inclination do i_raan = 1 , size ( x ) ran0 = x ( i_raan ) ! right ascension of ascending node write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '==============' write ( output_unit , '(A,1X,F12.6,1X,F12.6)' ) 'inc, ran:' , inc0 , ran0 write ( output_unit , '(A)' ) '' call seg % altitude_maintenance ( et0 , inc0 , ran0 , tru0 , dt_max , n_dvs , dv_total , xf ) z ( i_raan , i_inc ) = dv_total * km2m ! delta-v in m/s write ( output_unit , '(A)' ) '' write ( output_unit , '(A,I5)' ) 'n_dvs    = ' , n_dvs write ( output_unit , '(A,F10.6)' ) 'dv_total = ' , dv_total write ( output_unit , '(A)' ) '==============' write ( output_unit , '(A)' ) '' end do end do ! create a contour plot for the delta-v: call plt % add_contour ( x , y , z , linestyle = '-' , & linewidth = 2 , filled = . true ., cmap = 'Blues' ,& colorbar = . true ., istat = istat ) call plt % savefig ( 'lom.png' , pyfile = 'lom.py' , istat = istat ) ! print some stats: write ( * , * ) '' write ( * , * ) '-- Stats --' do i_inc = 1 , size ( y ) write ( * , * ) '' write ( * , * ) 'max dv for inc ' , y ( i_inc ), ' : ' , maxval ( z (:, i_inc )), 'm/s' write ( * , * ) 'min dv for inc ' , y ( i_inc ), ' : ' , minval ( z (:, i_inc )), 'm/s' ! also make plots for each inc value: write ( istr , '(I10)' ) int ( y ( i_inc )) call plt % destroy () call plt % initialize ( grid = . true ., xlabel = 'LAN (deg)' ,& ylabel = '$\\Delta v$ (m/s)' , figsize = [ 10 , 10 ],& title = 'Lunar Orbit Maintenance : deadband = ' // & trim ( deadband_alt_str ) // ' km : dt = ' // & trim ( dt_max_str ) // ' days : Inc=' // trim ( adjustl ( istr )),& real_fmt = '(E9.3)' ) call plt % add_plot ( x , z (:, i_inc ), linestyle = 'b-' , label = 'dv' , istat = istat ) call plt % savefig ( 'lom_INC=' // trim ( adjustl ( istr )) // '.png' ,& pyfile = 'lom_INC=' // trim ( adjustl ( istr )) // '.py' , istat = istat ) end do contains !***************************************************************************************** !***************************************************************************************** !> !  Read the config file and populate the global variables. subroutine read_config_file () use argv_module , only : argv use json_module , only : json_file implicit none character ( len = :), allocatable :: filename type ( json_file ) :: json logical :: status_ok , found character ( len = :), allocatable :: error_msg filename = argv ( 1 ) ! get the first argument if ( filename == '' ) then error stop 'The first command line arg should be the config file name' else write ( * , '(A)' ) 'Reading config file: ' // trim ( filename ) call json % initialize () ! no optional args for now call json % load ( filename ) if ( json % failed ()) then call json % check_for_errors ( error_msg = error_msg ) error stop error_msg else ! populate the run variables: call json % get ( 'dt_max' , dt_max , found ); if (. not . found ) error stop 'dt_max not found in config file.' call json % get ( 'et0' , et0 , found ); if (. not . found ) error stop 'et0 not found in config file.' call json % get ( 'tru0' , tru0 , found ); if (. not . found ) error stop 'tru0 not found in config file.' call json % get ( 'alt0' , alt0 , found ); if (. not . found ) error stop 'alt0 not found in config file.' call json % get ( 'deadband_alt' , deadband_alt , found ); if (. not . found ) error stop 'deadband_alt not found in config file.' call json % get ( 'inc_start' , inc_start , found ); if (. not . found ) error stop 'inc_start not found in config file.' call json % get ( 'inc_stop' , inc_stop , found ); if (. not . found ) error stop 'inc_stop not found in config file.' call json % get ( 'inc_step' , inc_step , found ); if (. not . found ) error stop 'inc_step not found in config file.' call json % get ( 'lan_start' , lan_start , found ); if (. not . found ) error stop 'lan_start not found in config file.' call json % get ( 'lan_stop' , lan_stop , found ); if (. not . found ) error stop 'lan_stop not found in config file.' call json % get ( 'lan_step' , lan_step , found ); if (. not . found ) error stop 'lan_step not found in config file.' call json % get ( 'grav_n' , grav_n , found ); if (. not . found ) error stop 'grav_n not found in config file.' call json % get ( 'grav_m' , grav_m , found ); if (. not . found ) error stop 'grav_m not found in config file.' call json % get ( 'ephemeris_file' , ephemeris_file , found ) if (. not . found ) error stop 'ephemeris_file not found in config file.' call json % get ( 'gravfile' , gravfile , found ) if (. not . found ) error stop 'gravfile not found in config file.' end if call json % destroy () end if end subroutine read_config_file !***************************************************************************************** !***************************************************************************************** !> !  Allocate the arrays. subroutine size_arrays ( xstart , xstop , xstep , ystart , ystop , ystep , x , y , z ) implicit none real ( wp ), intent ( in ) :: xstart , xstop , xstep , ystart , ystop , ystep real ( wp ), dimension (:), allocatable , intent ( out ) :: x , y real ( wp ), dimension (:,:), allocatable , intent ( out ) :: z !! f(x,y) integer :: i , j , nx , ny real ( wp ) :: tmp nx = 1 tmp = xstart x = [ tmp ] do tmp = tmp + xstep if ( tmp > xstop ) exit nx = nx + 1 x = [ x , tmp ] end do ny = 1 tmp = ystart y = [ tmp ] do tmp = tmp + ystep if ( tmp > ystop ) exit ny = ny + 1 y = [ y , tmp ] end do allocate ( z ( nx , ny )) z = 0.0_wp end subroutine size_arrays !***************************************************************************************** !***************************************************************************************** end program main !*****************************************************************************************","tags":"","loc":"sourcefile/main.f90.html"},{"title":"altitude_maintenance.f90 – lom","text":"Files dependent on this one sourcefile~~altitude_maintenance.f90~~AfferentGraph sourcefile~altitude_maintenance.f90 altitude_maintenance.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~altitude_maintenance.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules altitude_maintenance_module Source Code altitude_maintenance.f90 Source Code !***************************************************************************************** !> !  Altitude maintenance for low lunar orbits. ! !  Assumptions: ! !  * Circular low-lunar orbit. !  * Only periapsis altitude is controlled (all other elements float) !  * The low-fidelity IAU_MOON frame is used for the elements and gravity model. module altitude_maintenance_module use fortran_astrodynamics_toolkit use ddeabm_module , only : ddeabm_class , ddeabm_with_event_class use iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none private type , extends ( ddeabm_with_event_class ), public :: segment !! the main class for integrating a low-lunar orbit. private integer :: event = 0 !! event function to use: !! !! 1 = integrate until minimum altitude !! 2 = integrate to apoapsis real ( wp ) :: et_ref !! reference ephemeris time (sec) real ( wp ) :: nominal_altitude = 10 0.0_wp !! nominal altitude (km) real ( wp ) :: deadband = 1 0.0_wp !! altitude below nominal to trigger maneuver (km) real ( wp ) :: r_moon = 173 7.4_wp !! radius of the moon (km) logical :: include_third_bodies = . false . !! to also include Earth and Sun in force model type ( geopotential_model_pines ) :: grav !! central body geopotential model type ( jpl_ephemeris ) :: eph !! the ephemeris integer :: n_eoms = 6 !! size of EOM derivative vector [x,y,z,vx,vy,vz] real ( wp ) :: integrator_tol = 1.0e-12_wp !! integrator tols integer :: maxsteps = 1000000 !! integrator max steps integer :: grav_n = 8 !! max grav degree integer :: grav_m = 8 !! max grav order real ( wp ) :: root_tol = 1.0e-6_wp !! event tolerance for deadband (km) contains procedure , public :: initialize_seg => initialize_segment procedure , public :: altitude_maintenance end type segment contains !***************************************************************************************** !***************************************************************************************** !> !  Initialize the segment for integration. subroutine initialize_segment ( me , alt0 , deadband_alt , grav_n , grav_m ,& ephemeris_file , gravfile ) implicit none class ( segment ), intent ( inout ) :: me real ( wp ), intent ( in ) :: alt0 real ( wp ), intent ( in ) :: deadband_alt integer , intent ( in ) :: grav_n integer , intent ( in ) :: grav_m character ( len =* ), intent ( in ) :: ephemeris_file character ( len =* ), intent ( in ) :: gravfile logical :: status_ok ! set up the integrator: call me % initialize_event ( me % n_eoms , me % maxsteps , ballistic_derivs ,& [ me % integrator_tol ],[ me % integrator_tol ],& event_func , me % root_tol ) if ( me % include_third_bodies ) then ! set up the ephemeris: write ( output_unit , '(A)' ) 'loading ephemeris file: ' // trim ( ephemeris_file ) call me % eph % initialize ( filename = ephemeris_file , status_ok = status_ok ) if (. not . status_ok ) error stop 'error initializing ephemeris' end if ! set class variables for event function: me % nominal_altitude = alt0 me % deadband = deadband_alt me % grav_n = grav_n me % grav_m = grav_m ! set up the force model [main body is moon]: write ( output_unit , '(A)' ) 'loading gravity file: ' // trim ( gravfile ) call me % grav % initialize ( gravfile , me % grav_n , me % grav_m , status_ok ) if (. not . status_ok ) error stop 'error initializing gravity model' end subroutine initialize_segment !***************************************************************************************** !***************************************************************************************** !> !  Altitude maintenance for a circular lunar orbit - periapsis only control. subroutine altitude_maintenance ( seg , et0 , inc0 , ran0 , tru0 , dt_max , n_dvs , dv_total , xf ) implicit none class ( segment ), intent ( inout ) :: seg real ( wp ), intent ( in ) :: et0 !! initial ephemeris time (sec) real ( wp ), intent ( in ) :: inc0 !! initial inclination - IAU_MOON of date (deg) real ( wp ), intent ( in ) :: ran0 !! initial RAAN - IAU_MOON of date (deg) real ( wp ), intent ( in ) :: tru0 !! initial true anomaly - IAU_MOON of date (deg) real ( wp ), intent ( in ) :: dt_max !! how long to propagate (days) integer , intent ( out ) :: n_dvs !! number of DV maneuvers performed real ( wp ), intent ( out ) :: dv_total !! total DV (km/s) real ( wp ), dimension ( 6 ), intent ( out ) :: xf !! final state - inertial frame (km, km/s) real ( wp ), dimension ( 3 ) :: r !! position vector (km) real ( wp ), dimension ( 3 ) :: v !! velocity vector (km/s) real ( wp ), dimension ( 3 , 3 ) :: rotmat !! rotation matrix from ICRF to IAU_MOON real ( wp ), dimension ( 6 ) :: x !! J2000-Moon state vector integer :: idid !! integrator status flag real ( wp ) :: sma !! circular orbit semi-major axis (km) real ( wp ) :: min_altitude !! minimum altitude (km) real ( wp ) :: dv !! periapsis raise maneuver magnitude (km/s) real ( wp ) :: t !! integration time (sec from et0) real ( wp ) :: tf !! final integration time (sec from et0) real ( wp ) :: gval !! event function value real ( wp ) :: tru !! true anomaly (deg) ! initialize n_dvs = 0 dv_total = zero ! get initial state in J2000 - Cartesian for integration ! note that inc,ran are in moon-centered-of-date-frame ! [circular orbit so p=sma] sma = seg % r_moon + seg % nominal_altitude ! initial orbit sma (circular) call orbital_elements_to_rv ( body_moon % mu , sma , zero ,& inc0 * deg2rad , ran0 * deg2rad , zero , tru0 * deg2rad , r , v ) ! rotate from body-fixed moon of date to j2000: rotmat = icrf_to_iau_moon ( et0 ) ! rotation matrix from inertial to body-fixed Moon frame x ( 1 : 3 ) = matmul ( transpose ( rotmat ), r ) x ( 4 : 6 ) = matmul ( transpose ( rotmat ), v ) ! because using \"of date\" iau_moon frame ! times are relative to initial epoch (sec) seg % et_ref = et0 t = zero tf = dt_max * day2sec ! propagate until the altitude is less than min_altitude seg % event = 1 ! main integration loop: call seg % first_call () do call seg % integrate_to_event ( t , x , tf , idid = idid , gval = gval ) if ( idid < 0 ) then write ( error_unit , '(A,*(I5/))' ) 'idid: ' , idid error stop 'error in integrator' elseif ( idid == 2 . or . idid == 3 ) then ! if we reached the max time, then we are done, so exit exit elseif ( idid == 1000 ) then ! a root has been found select case ( seg % event ) case ( 1 ) ! if we hit the min altitude, then integrate to next apoapsis ! and raise the periapsis: seg % event = 2 ! propagate until apoapsis call seg % first_call () ! have to restart the integration ! since we just root solved ! compute the maneuver here that will be performed ! at next apoapsis to raise the periapsis, no matter what. dv = periapsis_raise_maneuver ( x , sma ) case ( 2 ) ! we have propagated to periapsis or apoapsis, if at apoapsis, ! perform a maneuver to raise periapsis ! if at periapsis, just continue on. ! compute current true anomaly: tru = true_anomaly ( x ) if ( tru < 17 9.0_wp . or . tru > 18 1.0_wp ) then ! we have to keep integrating, since we stopped at periapsis ! note: this is inefficient since we have to ! restart the integration. it would be better to prevent ! to root solver from stopping here. seg % event = 2 ! continue with mode 2 call seg % first_call () ! have to restart integration cycle else ! we are at apoapsis ! perform the maneuver we computed when ! the min altitude was triggered ! apply the maneuver along the current apoapsis velocity vector: x ( 4 : 6 ) = x ( 4 : 6 ) + dv * unit ( x ( 4 : 6 )) ! keep track of totals: n_dvs = n_dvs + 1 dv_total = dv_total + dv write ( output_unit , '(*(A,F12.6))' ) 'maneuver at ' , t * sec2hr , & ' hr : TRU = ' , tru , & ' : dv = ' , dv end if seg % event = 1 ! continue with normal mode call seg % first_call () ! have to restart the integration ! since we root solved and/or changed ! the state case default error stop 'invalid event value in altitude_maintenance' end select else write ( error_unit , '(A,I5)' ) 'unknown exit code from integrator: idid=' , idid error stop 'error in altitude_maintenance' end if end do ! final state: xf = x end subroutine altitude_maintenance !***************************************************************************************** !***************************************************************************************** !> !  Compute true anomaly [0, 360] deg. pure function true_anomaly ( rv ) result ( tru ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! [position,velocity] vector real ( wp ) :: tru !! true anomaly (deg) real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ) :: p , ecc , inc , raan , aop !! orbital elements r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) call rv_to_orbital_elements ( body_moon % mu , r , v , p , ecc , inc , raan , aop , tru ) tru = tru * rad2deg ! convert to deg if ( tru < zero ) tru = tru + 36 0.0_wp ! wrap from 0 to 369 end function true_anomaly !***************************************************************************************** !***************************************************************************************** !> !  Compute the maneuver at apoapsis to raise periapsis to the specified value. pure function periapsis_raise_maneuver ( rv , target_rp ) result ( dv ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! [position,velocity] vector real ( wp ), intent ( in ) :: target_rp !! the rp value to target real ( wp ) :: dv !! the maneuver to perform at apoapsis to target `target_rp` real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ) :: a , p , ecc , inc , raan , aop , tru !! orbital elements real ( wp ) :: rp1 , ra1 , vp1 , va1 , va2 !! periapsis/apoapsis pos/vel magnitudes r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) call rv_to_orbital_elements ( body_moon % mu , r , v , p , ecc , inc , raan , aop , tru ) a = p / ( one - ecc * ecc ) ! compute semi-major axis call periapsis_apoapsis ( body_moon % mu , a , ecc , rp1 , ra1 , vp1 , va1 ) ! apoapsis velocity for periapsis radius of target_rp va2 = sqrt ( two * body_moon % mu * target_rp / ( ra1 * ( target_rp + ra1 )) ) ! delta-v to raise periapsis back to target rp dv = va2 - va1 end function periapsis_raise_maneuver !***************************************************************************************** !***************************************************************************************** !> !  Compute radial velocity magnitude  \\dot{r}  pure function rdot ( rv ) result ( rd ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! [position,velocity] vector real ( wp ) :: rd !!  \\dot{r}  real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ) :: rmag !! position vector magnitude r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) rmag = norm2 ( r ) rd = dot_product ( r , v ) / rmag end function rdot !***************************************************************************************** !***************************************************************************************** !> !  Event function: when the altitude drops below the deadband. ! !@note Moon is assumed to be a sphere. subroutine event_func ( me , t , x , g ) implicit none class ( ddeabm_with_event_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension (:), intent ( in ) :: x !! state -- moon centered inertial frame real ( wp ), intent ( out ) :: g !! event function real ( wp ) :: alt !! altitude (km) select type ( me ) class is ( segment ) select case ( me % event ) case ( 1 ) ! g is offset from deadband altitude alt = norm2 ( x ( 1 : 3 )) - me % r_moon g = alt - ( me % nominal_altitude - me % deadband ) case ( 2 ) ! g is rdot, which is zero and periapsis ! and apoapsis of an ellipse: g = rdot ( x ( 1 : 6 )) ! TODO: figure out how to get it to ignore periapsis roots ! [maybe need to update DDEABM so we have more control ! over which roots it stops at] case default error stop 'invalid event value in event_func' end select class default error stop 'invalid class in event_func' end select end subroutine event_func !***************************************************************************************** !***************************************************************************************** !> !  Equations of motion for a ballistic orbit around the moon. subroutine ballistic_derivs ( me , t , x , xdot ) implicit none class ( ddeabm_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time [sec from epoch] real ( wp ), dimension (:), intent ( in ) :: x !! state [r,v] in inertial frame (moon-centered) real ( wp ), dimension (:), intent ( out ) :: xdot !! derivative of state ( dx/dt ) real ( wp ), dimension ( 3 ) :: r , rb , v reaL ( wp ), dimension ( 6 ) :: rv_earth_wrt_moon , rv_sun_wrt_moon real ( wp ), dimension ( 3 , 3 ) :: rotmat real ( wp ), dimension ( 3 ) :: a_geopot real ( wp ), dimension ( 3 ) :: a_earth real ( wp ), dimension ( 3 ) :: a_sun real ( wp ), dimension ( 3 ) :: a_third_body real ( wp ) :: et !! ephemeris time of `t` logical :: status_ok !! ephemeris status flag select type ( me ) class is ( segment ) ! get state: r = x ( 1 : 3 ) v = x ( 4 : 6 ) ! compute ephemeris time [sec]: et = t + me % et_ref ! geopotential gravity: rotmat = icrf_to_iau_moon ( et ) ! rotation matrix from inertial to body-fixed Moon frame rb = matmul ( rotmat , r ) ! r in body-fixed frame call me % grav % get_acc ( rb , me % grav_n , me % grav_m , a_geopot ) ! get the acc due to the geopotential a_geopot = matmul ( transpose ( rotmat ), a_geopot ) ! convert acc back to inertial frame if ( me % include_third_bodies ) then ! third-body state vectors (wrt the central body, which is the moon in this case): ! [inertial frame] call me % eph % get_rv ( et , body_earth , body_moon , rv_earth_wrt_moon , status_ok ) call me % eph % get_rv ( et , body_sun , body_moon , rv_sun_wrt_moon , status_ok ) ! third-body perturbation (earth & sun): a_third_body = 0.0_wp call third_body_gravity ( r , rv_earth_wrt_moon ( 1 : 3 ), body_earth % mu , a_earth ) call third_body_gravity ( r , rv_sun_wrt_moon ( 1 : 3 ), body_sun % mu , a_sun ) a_third_body = a_earth + a_sun else a_third_body = zero end if !total derivative vector: xdot ( 1 : 3 ) = v xdot ( 4 : 6 ) = a_geopot + a_third_body class default error stop 'invalid class in ballistic_derivs' end select end subroutine ballistic_derivs !***************************************************************************************** !***************************************************************************************** end module altitude_maintenance_module !*****************************************************************************************","tags":"","loc":"sourcefile/altitude_maintenance.f90.html"},{"title":"segment – lom ","text":"type, public, extends(ddeabm_with_event_class) :: segment the main class for integrating a low-lunar orbit. Inherits type~~segment~~InheritsGraph type~segment segment jpl_ephemeris jpl_ephemeris type~segment->jpl_ephemeris eph geopotential_model_pines geopotential_model_pines type~segment->geopotential_model_pines grav ddeabm_with_event_class ddeabm_with_event_class type~segment->ddeabm_with_event_class Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables event et_ref nominal_altitude deadband r_moon include_third_bodies grav eph n_eoms integrator_tol maxsteps grav_n grav_m root_tol Type-Bound Procedures initialize_seg altitude_maintenance Source Code segment Components Type Visibility Attributes Name Initial integer, public :: event = 0 event function to use: 1 = integrate until minimum altitude\n2 = integrate to apoapsis real(kind=wp), public :: et_ref reference ephemeris time (sec) real(kind=wp), public :: nominal_altitude = 100.0_wp nominal altitude (km) real(kind=wp), public :: deadband = 10.0_wp altitude below nominal to trigger maneuver (km) real(kind=wp), public :: r_moon = 1737.4_wp radius of the moon (km) logical, public :: include_third_bodies = .false. to also include Earth and Sun in force model type(geopotential_model_pines), public :: grav central body geopotential model type(jpl_ephemeris), public :: eph the ephemeris integer, public :: n_eoms = 6 size of EOM derivative vector [x,y,z,vx,vy,vz] real(kind=wp), public :: integrator_tol = 1.0e-12_wp integrator tols integer, public :: maxsteps = 1000000 integrator max steps integer, public :: grav_n = 8 max grav degree integer, public :: grav_m = 8 max grav order real(kind=wp), public :: root_tol = 1.0e-6_wp event tolerance for deadband (km) Type-Bound Procedures procedure, public :: initialize_seg => initialize_segment private subroutine initialize_segment (me, alt0, deadband_alt, grav_n, grav_m, ephemeris_file, gravfile) Initialize the segment for integration. Arguments Type Intent Optional Attributes Name class( segment ), intent(inout) :: me real(kind=wp), intent(in) :: alt0 real(kind=wp), intent(in) :: deadband_alt integer, intent(in) :: grav_n integer, intent(in) :: grav_m character(len=*), intent(in) :: ephemeris_file character(len=*), intent(in) :: gravfile procedure, public :: altitude_maintenance private subroutine altitude_maintenance (seg, et0, inc0, ran0, tru0, dt_max, n_dvs, dv_total, xf) Altitude maintenance for a circular lunar orbit - periapsis only control. Arguments Type Intent Optional Attributes Name class( segment ), intent(inout) :: seg real(kind=wp), intent(in) :: et0 initial ephemeris time (sec) real(kind=wp), intent(in) :: inc0 initial inclination - IAU_MOON of date (deg) real(kind=wp), intent(in) :: ran0 initial RAAN - IAU_MOON of date (deg) real(kind=wp), intent(in) :: tru0 initial true anomaly - IAU_MOON of date (deg) real(kind=wp), intent(in) :: dt_max how long to propagate (days) integer, intent(out) :: n_dvs number of DV maneuvers performed real(kind=wp), intent(out) :: dv_total total DV (km/s) real(kind=wp), intent(out), dimension(6) :: xf final state - inertial frame (km, km/s) Source Code type , extends ( ddeabm_with_event_class ), public :: segment !! the main class for integrating a low-lunar orbit. private integer :: event = 0 !! event function to use: !! !! 1 = integrate until minimum altitude !! 2 = integrate to apoapsis real ( wp ) :: et_ref !! reference ephemeris time (sec) real ( wp ) :: nominal_altitude = 10 0.0_wp !! nominal altitude (km) real ( wp ) :: deadband = 1 0.0_wp !! altitude below nominal to trigger maneuver (km) real ( wp ) :: r_moon = 173 7.4_wp !! radius of the moon (km) logical :: include_third_bodies = . false . !! to also include Earth and Sun in force model type ( geopotential_model_pines ) :: grav !! central body geopotential model type ( jpl_ephemeris ) :: eph !! the ephemeris integer :: n_eoms = 6 !! size of EOM derivative vector [x,y,z,vx,vy,vz] real ( wp ) :: integrator_tol = 1.0e-12_wp !! integrator tols integer :: maxsteps = 1000000 !! integrator max steps integer :: grav_n = 8 !! max grav degree integer :: grav_m = 8 !! max grav order real ( wp ) :: root_tol = 1.0e-6_wp !! event tolerance for deadband (km) contains procedure , public :: initialize_seg => initialize_segment procedure , public :: altitude_maintenance end type segment","tags":"","loc":"type/segment.html"},{"title":"read_config_file – lom","text":"subroutine read_config_file() Uses json_module argv_module proc~~read_config_file~~UsesGraph proc~read_config_file read_config_file argv_module argv_module proc~read_config_file->argv_module json_module json_module proc~read_config_file->json_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Read the config file and populate the global variables. Arguments None Calls proc~~read_config_file~~CallsGraph proc~read_config_file read_config_file argv argv proc~read_config_file->argv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_config_file~~CalledByGraph proc~read_config_file read_config_file program~main main program~main->proc~read_config_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_config_file Source Code subroutine read_config_file () use argv_module , only : argv use json_module , only : json_file implicit none character ( len = :), allocatable :: filename type ( json_file ) :: json logical :: status_ok , found character ( len = :), allocatable :: error_msg filename = argv ( 1 ) ! get the first argument if ( filename == '' ) then error stop 'The first command line arg should be the config file name' else write ( * , '(A)' ) 'Reading config file: ' // trim ( filename ) call json % initialize () ! no optional args for now call json % load ( filename ) if ( json % failed ()) then call json % check_for_errors ( error_msg = error_msg ) error stop error_msg else ! populate the run variables: call json % get ( 'dt_max' , dt_max , found ); if (. not . found ) error stop 'dt_max not found in config file.' call json % get ( 'et0' , et0 , found ); if (. not . found ) error stop 'et0 not found in config file.' call json % get ( 'tru0' , tru0 , found ); if (. not . found ) error stop 'tru0 not found in config file.' call json % get ( 'alt0' , alt0 , found ); if (. not . found ) error stop 'alt0 not found in config file.' call json % get ( 'deadband_alt' , deadband_alt , found ); if (. not . found ) error stop 'deadband_alt not found in config file.' call json % get ( 'inc_start' , inc_start , found ); if (. not . found ) error stop 'inc_start not found in config file.' call json % get ( 'inc_stop' , inc_stop , found ); if (. not . found ) error stop 'inc_stop not found in config file.' call json % get ( 'inc_step' , inc_step , found ); if (. not . found ) error stop 'inc_step not found in config file.' call json % get ( 'lan_start' , lan_start , found ); if (. not . found ) error stop 'lan_start not found in config file.' call json % get ( 'lan_stop' , lan_stop , found ); if (. not . found ) error stop 'lan_stop not found in config file.' call json % get ( 'lan_step' , lan_step , found ); if (. not . found ) error stop 'lan_step not found in config file.' call json % get ( 'grav_n' , grav_n , found ); if (. not . found ) error stop 'grav_n not found in config file.' call json % get ( 'grav_m' , grav_m , found ); if (. not . found ) error stop 'grav_m not found in config file.' call json % get ( 'ephemeris_file' , ephemeris_file , found ) if (. not . found ) error stop 'ephemeris_file not found in config file.' call json % get ( 'gravfile' , gravfile , found ) if (. not . found ) error stop 'gravfile not found in config file.' end if call json % destroy () end if end subroutine read_config_file","tags":"","loc":"proc/read_config_file.html"},{"title":"size_arrays – lom","text":"subroutine size_arrays(xstart, xstop, xstep, ystart, ystop, ystep, x, y, z) Allocate the arrays. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xstart real(kind=wp), intent(in) :: xstop real(kind=wp), intent(in) :: xstep real(kind=wp), intent(in) :: ystart real(kind=wp), intent(in) :: ystop real(kind=wp), intent(in) :: ystep real(kind=wp), intent(out), dimension(:), allocatable :: x real(kind=wp), intent(out), dimension(:), allocatable :: y real(kind=wp), intent(out), dimension(:,:), allocatable :: z f(x,y) Called by proc~~size_arrays~~CalledByGraph proc~size_arrays size_arrays program~main main program~main->proc~size_arrays Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code size_arrays Source Code subroutine size_arrays ( xstart , xstop , xstep , ystart , ystop , ystep , x , y , z ) implicit none real ( wp ), intent ( in ) :: xstart , xstop , xstep , ystart , ystop , ystep real ( wp ), dimension (:), allocatable , intent ( out ) :: x , y real ( wp ), dimension (:,:), allocatable , intent ( out ) :: z !! f(x,y) integer :: i , j , nx , ny real ( wp ) :: tmp nx = 1 tmp = xstart x = [ tmp ] do tmp = tmp + xstep if ( tmp > xstop ) exit nx = nx + 1 x = [ x , tmp ] end do ny = 1 tmp = ystart y = [ tmp ] do tmp = tmp + ystep if ( tmp > ystop ) exit ny = ny + 1 y = [ y , tmp ] end do allocate ( z ( nx , ny )) z = 0.0_wp end subroutine size_arrays","tags":"","loc":"proc/size_arrays.html"},{"title":"true_anomaly – lom","text":"private pure function true_anomaly(rv) result(tru) Compute true anomaly [0, 360] deg. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv [position,velocity] vector Return Value real(kind=wp) true anomaly (deg) Calls proc~~true_anomaly~~CallsGraph proc~true_anomaly true_anomaly rv_to_orbital_elements rv_to_orbital_elements proc~true_anomaly->rv_to_orbital_elements Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~true_anomaly~~CalledByGraph proc~true_anomaly true_anomaly proc~altitude_maintenance altitude_maintenance proc~altitude_maintenance->proc~true_anomaly Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code true_anomaly Source Code pure function true_anomaly ( rv ) result ( tru ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! [position,velocity] vector real ( wp ) :: tru !! true anomaly (deg) real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ) :: p , ecc , inc , raan , aop !! orbital elements r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) call rv_to_orbital_elements ( body_moon % mu , r , v , p , ecc , inc , raan , aop , tru ) tru = tru * rad2deg ! convert to deg if ( tru < zero ) tru = tru + 36 0.0_wp ! wrap from 0 to 369 end function true_anomaly","tags":"","loc":"proc/true_anomaly.html"},{"title":"periapsis_raise_maneuver – lom","text":"private pure function periapsis_raise_maneuver(rv, target_rp) result(dv) Compute the maneuver at apoapsis to raise periapsis to the specified value. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv [position,velocity] vector real(kind=wp), intent(in) :: target_rp the rp value to target Return Value real(kind=wp) the maneuver to perform at apoapsis to target target_rp Calls proc~~periapsis_raise_maneuver~~CallsGraph proc~periapsis_raise_maneuver periapsis_raise_maneuver rv_to_orbital_elements rv_to_orbital_elements proc~periapsis_raise_maneuver->rv_to_orbital_elements periapsis_apoapsis periapsis_apoapsis proc~periapsis_raise_maneuver->periapsis_apoapsis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~periapsis_raise_maneuver~~CalledByGraph proc~periapsis_raise_maneuver periapsis_raise_maneuver proc~altitude_maintenance altitude_maintenance proc~altitude_maintenance->proc~periapsis_raise_maneuver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code periapsis_raise_maneuver Source Code pure function periapsis_raise_maneuver ( rv , target_rp ) result ( dv ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! [position,velocity] vector real ( wp ), intent ( in ) :: target_rp !! the rp value to target real ( wp ) :: dv !! the maneuver to perform at apoapsis to target `target_rp` real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ) :: a , p , ecc , inc , raan , aop , tru !! orbital elements real ( wp ) :: rp1 , ra1 , vp1 , va1 , va2 !! periapsis/apoapsis pos/vel magnitudes r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) call rv_to_orbital_elements ( body_moon % mu , r , v , p , ecc , inc , raan , aop , tru ) a = p / ( one - ecc * ecc ) ! compute semi-major axis call periapsis_apoapsis ( body_moon % mu , a , ecc , rp1 , ra1 , vp1 , va1 ) ! apoapsis velocity for periapsis radius of target_rp va2 = sqrt ( two * body_moon % mu * target_rp / ( ra1 * ( target_rp + ra1 )) ) ! delta-v to raise periapsis back to target rp dv = va2 - va1 end function periapsis_raise_maneuver","tags":"","loc":"proc/periapsis_raise_maneuver.html"},{"title":"rdot – lom","text":"private pure function rdot(rv) result(rd) Compute radial velocity magnitude Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv [position,velocity] vector Return Value real(kind=wp) Called by proc~~rdot~~CalledByGraph proc~rdot rdot proc~event_func event_func proc~event_func->proc~rdot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rdot Source Code pure function rdot ( rv ) result ( rd ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! [position,velocity] vector real ( wp ) :: rd !!  \\dot{r}  real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ) :: rmag !! position vector magnitude r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) rmag = norm2 ( r ) rd = dot_product ( r , v ) / rmag end function rdot","tags":"","loc":"proc/rdot.html"},{"title":"initialize_segment – lom","text":"private subroutine initialize_segment(me, alt0, deadband_alt, grav_n, grav_m, ephemeris_file, gravfile) Initialize the segment for integration. Arguments Type Intent Optional Attributes Name class( segment ), intent(inout) :: me real(kind=wp), intent(in) :: alt0 real(kind=wp), intent(in) :: deadband_alt integer, intent(in) :: grav_n integer, intent(in) :: grav_m character(len=*), intent(in) :: ephemeris_file character(len=*), intent(in) :: gravfile Contents Source Code initialize_segment Source Code subroutine initialize_segment ( me , alt0 , deadband_alt , grav_n , grav_m ,& ephemeris_file , gravfile ) implicit none class ( segment ), intent ( inout ) :: me real ( wp ), intent ( in ) :: alt0 real ( wp ), intent ( in ) :: deadband_alt integer , intent ( in ) :: grav_n integer , intent ( in ) :: grav_m character ( len =* ), intent ( in ) :: ephemeris_file character ( len =* ), intent ( in ) :: gravfile logical :: status_ok ! set up the integrator: call me % initialize_event ( me % n_eoms , me % maxsteps , ballistic_derivs ,& [ me % integrator_tol ],[ me % integrator_tol ],& event_func , me % root_tol ) if ( me % include_third_bodies ) then ! set up the ephemeris: write ( output_unit , '(A)' ) 'loading ephemeris file: ' // trim ( ephemeris_file ) call me % eph % initialize ( filename = ephemeris_file , status_ok = status_ok ) if (. not . status_ok ) error stop 'error initializing ephemeris' end if ! set class variables for event function: me % nominal_altitude = alt0 me % deadband = deadband_alt me % grav_n = grav_n me % grav_m = grav_m ! set up the force model [main body is moon]: write ( output_unit , '(A)' ) 'loading gravity file: ' // trim ( gravfile ) call me % grav % initialize ( gravfile , me % grav_n , me % grav_m , status_ok ) if (. not . status_ok ) error stop 'error initializing gravity model' end subroutine initialize_segment","tags":"","loc":"proc/initialize_segment.html"},{"title":"altitude_maintenance – lom","text":"private subroutine altitude_maintenance(seg, et0, inc0, ran0, tru0, dt_max, n_dvs, dv_total, xf) Altitude maintenance for a circular lunar orbit - periapsis only control. Arguments Type Intent Optional Attributes Name class( segment ), intent(inout) :: seg real(kind=wp), intent(in) :: et0 initial ephemeris time (sec) real(kind=wp), intent(in) :: inc0 initial inclination - IAU_MOON of date (deg) real(kind=wp), intent(in) :: ran0 initial RAAN - IAU_MOON of date (deg) real(kind=wp), intent(in) :: tru0 initial true anomaly - IAU_MOON of date (deg) real(kind=wp), intent(in) :: dt_max how long to propagate (days) integer, intent(out) :: n_dvs number of DV maneuvers performed real(kind=wp), intent(out) :: dv_total total DV (km/s) real(kind=wp), intent(out), dimension(6) :: xf final state - inertial frame (km, km/s) Calls proc~~altitude_maintenance~~CallsGraph proc~altitude_maintenance altitude_maintenance proc~true_anomaly true_anomaly proc~altitude_maintenance->proc~true_anomaly unit unit proc~altitude_maintenance->unit icrf_to_iau_moon icrf_to_iau_moon proc~altitude_maintenance->icrf_to_iau_moon proc~periapsis_raise_maneuver periapsis_raise_maneuver proc~altitude_maintenance->proc~periapsis_raise_maneuver orbital_elements_to_rv orbital_elements_to_rv proc~altitude_maintenance->orbital_elements_to_rv rv_to_orbital_elements rv_to_orbital_elements proc~true_anomaly->rv_to_orbital_elements proc~periapsis_raise_maneuver->rv_to_orbital_elements periapsis_apoapsis periapsis_apoapsis proc~periapsis_raise_maneuver->periapsis_apoapsis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code altitude_maintenance Source Code subroutine altitude_maintenance ( seg , et0 , inc0 , ran0 , tru0 , dt_max , n_dvs , dv_total , xf ) implicit none class ( segment ), intent ( inout ) :: seg real ( wp ), intent ( in ) :: et0 !! initial ephemeris time (sec) real ( wp ), intent ( in ) :: inc0 !! initial inclination - IAU_MOON of date (deg) real ( wp ), intent ( in ) :: ran0 !! initial RAAN - IAU_MOON of date (deg) real ( wp ), intent ( in ) :: tru0 !! initial true anomaly - IAU_MOON of date (deg) real ( wp ), intent ( in ) :: dt_max !! how long to propagate (days) integer , intent ( out ) :: n_dvs !! number of DV maneuvers performed real ( wp ), intent ( out ) :: dv_total !! total DV (km/s) real ( wp ), dimension ( 6 ), intent ( out ) :: xf !! final state - inertial frame (km, km/s) real ( wp ), dimension ( 3 ) :: r !! position vector (km) real ( wp ), dimension ( 3 ) :: v !! velocity vector (km/s) real ( wp ), dimension ( 3 , 3 ) :: rotmat !! rotation matrix from ICRF to IAU_MOON real ( wp ), dimension ( 6 ) :: x !! J2000-Moon state vector integer :: idid !! integrator status flag real ( wp ) :: sma !! circular orbit semi-major axis (km) real ( wp ) :: min_altitude !! minimum altitude (km) real ( wp ) :: dv !! periapsis raise maneuver magnitude (km/s) real ( wp ) :: t !! integration time (sec from et0) real ( wp ) :: tf !! final integration time (sec from et0) real ( wp ) :: gval !! event function value real ( wp ) :: tru !! true anomaly (deg) ! initialize n_dvs = 0 dv_total = zero ! get initial state in J2000 - Cartesian for integration ! note that inc,ran are in moon-centered-of-date-frame ! [circular orbit so p=sma] sma = seg % r_moon + seg % nominal_altitude ! initial orbit sma (circular) call orbital_elements_to_rv ( body_moon % mu , sma , zero ,& inc0 * deg2rad , ran0 * deg2rad , zero , tru0 * deg2rad , r , v ) ! rotate from body-fixed moon of date to j2000: rotmat = icrf_to_iau_moon ( et0 ) ! rotation matrix from inertial to body-fixed Moon frame x ( 1 : 3 ) = matmul ( transpose ( rotmat ), r ) x ( 4 : 6 ) = matmul ( transpose ( rotmat ), v ) ! because using \"of date\" iau_moon frame ! times are relative to initial epoch (sec) seg % et_ref = et0 t = zero tf = dt_max * day2sec ! propagate until the altitude is less than min_altitude seg % event = 1 ! main integration loop: call seg % first_call () do call seg % integrate_to_event ( t , x , tf , idid = idid , gval = gval ) if ( idid < 0 ) then write ( error_unit , '(A,*(I5/))' ) 'idid: ' , idid error stop 'error in integrator' elseif ( idid == 2 . or . idid == 3 ) then ! if we reached the max time, then we are done, so exit exit elseif ( idid == 1000 ) then ! a root has been found select case ( seg % event ) case ( 1 ) ! if we hit the min altitude, then integrate to next apoapsis ! and raise the periapsis: seg % event = 2 ! propagate until apoapsis call seg % first_call () ! have to restart the integration ! since we just root solved ! compute the maneuver here that will be performed ! at next apoapsis to raise the periapsis, no matter what. dv = periapsis_raise_maneuver ( x , sma ) case ( 2 ) ! we have propagated to periapsis or apoapsis, if at apoapsis, ! perform a maneuver to raise periapsis ! if at periapsis, just continue on. ! compute current true anomaly: tru = true_anomaly ( x ) if ( tru < 17 9.0_wp . or . tru > 18 1.0_wp ) then ! we have to keep integrating, since we stopped at periapsis ! note: this is inefficient since we have to ! restart the integration. it would be better to prevent ! to root solver from stopping here. seg % event = 2 ! continue with mode 2 call seg % first_call () ! have to restart integration cycle else ! we are at apoapsis ! perform the maneuver we computed when ! the min altitude was triggered ! apply the maneuver along the current apoapsis velocity vector: x ( 4 : 6 ) = x ( 4 : 6 ) + dv * unit ( x ( 4 : 6 )) ! keep track of totals: n_dvs = n_dvs + 1 dv_total = dv_total + dv write ( output_unit , '(*(A,F12.6))' ) 'maneuver at ' , t * sec2hr , & ' hr : TRU = ' , tru , & ' : dv = ' , dv end if seg % event = 1 ! continue with normal mode call seg % first_call () ! have to restart the integration ! since we root solved and/or changed ! the state case default error stop 'invalid event value in altitude_maintenance' end select else write ( error_unit , '(A,I5)' ) 'unknown exit code from integrator: idid=' , idid error stop 'error in altitude_maintenance' end if end do ! final state: xf = x end subroutine altitude_maintenance","tags":"","loc":"proc/altitude_maintenance.html"},{"title":"event_func – lom","text":"private subroutine event_func(me, t, x, g) Event function: when the altitude drops below the deadband. Note Moon is assumed to be a sphere. Arguments Type Intent Optional Attributes Name class(ddeabm_with_event_class), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state -- moon centered inertial frame real(kind=wp), intent(out) :: g event function Calls proc~~event_func~~CallsGraph proc~event_func event_func proc~rdot rdot proc~event_func->proc~rdot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code event_func Source Code subroutine event_func ( me , t , x , g ) implicit none class ( ddeabm_with_event_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension (:), intent ( in ) :: x !! state -- moon centered inertial frame real ( wp ), intent ( out ) :: g !! event function real ( wp ) :: alt !! altitude (km) select type ( me ) class is ( segment ) select case ( me % event ) case ( 1 ) ! g is offset from deadband altitude alt = norm2 ( x ( 1 : 3 )) - me % r_moon g = alt - ( me % nominal_altitude - me % deadband ) case ( 2 ) ! g is rdot, which is zero and periapsis ! and apoapsis of an ellipse: g = rdot ( x ( 1 : 6 )) ! TODO: figure out how to get it to ignore periapsis roots ! [maybe need to update DDEABM so we have more control ! over which roots it stops at] case default error stop 'invalid event value in event_func' end select class default error stop 'invalid class in event_func' end select end subroutine event_func","tags":"","loc":"proc/event_func.html"},{"title":"ballistic_derivs – lom","text":"private subroutine ballistic_derivs(me, t, x, xdot) Equations of motion for a ballistic orbit around the moon. Arguments Type Intent Optional Attributes Name class(ddeabm_class), intent(inout) :: me real(kind=wp), intent(in) :: t time [sec from epoch] real(kind=wp), intent(in), dimension(:) :: x state [r,v] in inertial frame (moon-centered) real(kind=wp), intent(out), dimension(:) :: xdot derivative of state ( ) Calls proc~~ballistic_derivs~~CallsGraph proc~ballistic_derivs ballistic_derivs icrf_to_iau_moon icrf_to_iau_moon proc~ballistic_derivs->icrf_to_iau_moon third_body_gravity third_body_gravity proc~ballistic_derivs->third_body_gravity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ballistic_derivs Source Code subroutine ballistic_derivs ( me , t , x , xdot ) implicit none class ( ddeabm_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time [sec from epoch] real ( wp ), dimension (:), intent ( in ) :: x !! state [r,v] in inertial frame (moon-centered) real ( wp ), dimension (:), intent ( out ) :: xdot !! derivative of state ( dx/dt ) real ( wp ), dimension ( 3 ) :: r , rb , v reaL ( wp ), dimension ( 6 ) :: rv_earth_wrt_moon , rv_sun_wrt_moon real ( wp ), dimension ( 3 , 3 ) :: rotmat real ( wp ), dimension ( 3 ) :: a_geopot real ( wp ), dimension ( 3 ) :: a_earth real ( wp ), dimension ( 3 ) :: a_sun real ( wp ), dimension ( 3 ) :: a_third_body real ( wp ) :: et !! ephemeris time of `t` logical :: status_ok !! ephemeris status flag select type ( me ) class is ( segment ) ! get state: r = x ( 1 : 3 ) v = x ( 4 : 6 ) ! compute ephemeris time [sec]: et = t + me % et_ref ! geopotential gravity: rotmat = icrf_to_iau_moon ( et ) ! rotation matrix from inertial to body-fixed Moon frame rb = matmul ( rotmat , r ) ! r in body-fixed frame call me % grav % get_acc ( rb , me % grav_n , me % grav_m , a_geopot ) ! get the acc due to the geopotential a_geopot = matmul ( transpose ( rotmat ), a_geopot ) ! convert acc back to inertial frame if ( me % include_third_bodies ) then ! third-body state vectors (wrt the central body, which is the moon in this case): ! [inertial frame] call me % eph % get_rv ( et , body_earth , body_moon , rv_earth_wrt_moon , status_ok ) call me % eph % get_rv ( et , body_sun , body_moon , rv_sun_wrt_moon , status_ok ) ! third-body perturbation (earth & sun): a_third_body = 0.0_wp call third_body_gravity ( r , rv_earth_wrt_moon ( 1 : 3 ), body_earth % mu , a_earth ) call third_body_gravity ( r , rv_sun_wrt_moon ( 1 : 3 ), body_sun % mu , a_sun ) a_third_body = a_earth + a_sun else a_third_body = zero end if !total derivative vector: xdot ( 1 : 3 ) = v xdot ( 4 : 6 ) = a_geopot + a_third_body class default error stop 'invalid class in ballistic_derivs' end select end subroutine ballistic_derivs","tags":"","loc":"proc/ballistic_derivs.html"},{"title":"altitude_maintenance_module – lom","text":"Altitude maintenance for low lunar orbits. Assumptions: Circular low-lunar orbit. Only periapsis altitude is controlled (all other elements float) The low-fidelity IAU_MOON frame is used for the elements and gravity model. Uses ddeabm_module iso_fortran_env fortran_astrodynamics_toolkit module~~altitude_maintenance_module~~UsesGraph module~altitude_maintenance_module altitude_maintenance_module ddeabm_module ddeabm_module module~altitude_maintenance_module->ddeabm_module fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~altitude_maintenance_module->fortran_astrodynamics_toolkit iso_fortran_env iso_fortran_env module~altitude_maintenance_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~altitude_maintenance_module~~UsedByGraph module~altitude_maintenance_module altitude_maintenance_module program~main main program~main->module~altitude_maintenance_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types segment Functions true_anomaly periapsis_raise_maneuver rdot Subroutines initialize_segment altitude_maintenance event_func ballistic_derivs Derived Types type, public, extends(ddeabm_with_event_class) :: segment the main class for integrating a low-lunar orbit. Components Type Visibility Attributes Name Initial integer, public :: event = 0 event function to use: Read more… real(kind=wp), public :: et_ref reference ephemeris time (sec) real(kind=wp), public :: nominal_altitude = 100.0_wp nominal altitude (km) real(kind=wp), public :: deadband = 10.0_wp altitude below nominal to trigger maneuver (km) real(kind=wp), public :: r_moon = 1737.4_wp radius of the moon (km) logical, public :: include_third_bodies = .false. to also include Earth and Sun in force model type(geopotential_model_pines), public :: grav central body geopotential model type(jpl_ephemeris), public :: eph the ephemeris integer, public :: n_eoms = 6 size of EOM derivative vector [x,y,z,vx,vy,vz] real(kind=wp), public :: integrator_tol = 1.0e-12_wp integrator tols integer, public :: maxsteps = 1000000 integrator max steps integer, public :: grav_n = 8 max grav degree integer, public :: grav_m = 8 max grav order real(kind=wp), public :: root_tol = 1.0e-6_wp event tolerance for deadband (km) Type-Bound Procedures procedure, public :: initialize_seg => initialize_segment procedure, public :: altitude_maintenance Functions private pure function true_anomaly (rv) result(tru) Compute true anomaly [0, 360] deg. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv [position,velocity] vector Return Value real(kind=wp) true anomaly (deg) private pure function periapsis_raise_maneuver (rv, target_rp) result(dv) Compute the maneuver at apoapsis to raise periapsis to the specified value. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv [position,velocity] vector real(kind=wp), intent(in) :: target_rp the rp value to target Return Value real(kind=wp) the maneuver to perform at apoapsis to target target_rp private pure function rdot (rv) result(rd) Compute radial velocity magnitude Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv [position,velocity] vector Return Value real(kind=wp) Subroutines private subroutine initialize_segment (me, alt0, deadband_alt, grav_n, grav_m, ephemeris_file, gravfile) Initialize the segment for integration. Arguments Type Intent Optional Attributes Name class( segment ), intent(inout) :: me real(kind=wp), intent(in) :: alt0 real(kind=wp), intent(in) :: deadband_alt integer, intent(in) :: grav_n integer, intent(in) :: grav_m character(len=*), intent(in) :: ephemeris_file character(len=*), intent(in) :: gravfile private subroutine altitude_maintenance (seg, et0, inc0, ran0, tru0, dt_max, n_dvs, dv_total, xf) Altitude maintenance for a circular lunar orbit - periapsis only control. Arguments Type Intent Optional Attributes Name class( segment ), intent(inout) :: seg real(kind=wp), intent(in) :: et0 initial ephemeris time (sec) real(kind=wp), intent(in) :: inc0 initial inclination - IAU_MOON of date (deg) real(kind=wp), intent(in) :: ran0 initial RAAN - IAU_MOON of date (deg) real(kind=wp), intent(in) :: tru0 initial true anomaly - IAU_MOON of date (deg) real(kind=wp), intent(in) :: dt_max how long to propagate (days) integer, intent(out) :: n_dvs number of DV maneuvers performed real(kind=wp), intent(out) :: dv_total total DV (km/s) real(kind=wp), intent(out), dimension(6) :: xf final state - inertial frame (km, km/s) private subroutine event_func (me, t, x, g) Event function: when the altitude drops below the deadband. Read more… Arguments Type Intent Optional Attributes Name class(ddeabm_with_event_class), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state -- moon centered inertial frame real(kind=wp), intent(out) :: g event function private subroutine ballistic_derivs (me, t, x, xdot) Equations of motion for a ballistic orbit around the moon. Arguments Type Intent Optional Attributes Name class(ddeabm_class), intent(inout) :: me real(kind=wp), intent(in) :: t time [sec from epoch] real(kind=wp), intent(in), dimension(:) :: x state [r,v] in inertial frame (moon-centered) real(kind=wp), intent(out), dimension(:) :: xdot derivative of state ( )","tags":"","loc":"module/altitude_maintenance_module.html"},{"title":"main – lom","text":"Uses altitude_maintenance_module iso_fortran_env pyplot_module fortran_astrodynamics_toolkit program~~main~~UsesGraph program~main main fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit program~main->fortran_astrodynamics_toolkit module~altitude_maintenance_module altitude_maintenance_module program~main->module~altitude_maintenance_module pyplot_module pyplot_module program~main->pyplot_module iso_fortran_env iso_fortran_env program~main->iso_fortran_env module~altitude_maintenance_module->fortran_astrodynamics_toolkit module~altitude_maintenance_module->iso_fortran_env ddeabm_module ddeabm_module module~altitude_maintenance_module->ddeabm_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Altitude maintenance test program Calls program~~main~~CallsGraph program~main main proc~read_config_file read_config_file program~main->proc~read_config_file proc~size_arrays size_arrays program~main->proc~size_arrays argv argv proc~read_config_file->argv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dt_max et0 tru0 alt0 deadband_alt inc_start inc_stop inc_step lan_start lan_stop lan_step grav_n grav_m ephemeris_file gravfile x y z inc0 ran0 n_dvs dv_total xf i_inc i_raan plt istat istr dt_max_str deadband_alt_str seg Subroutines read_config_file size_arrays Source Code main Variables Type Attributes Name Initial real(kind=wp) :: dt_max how long to propagate (days) real(kind=wp) :: et0 initial ephemeris time (sec)\n(only matters if including Earth/Sun perturbations) real(kind=wp) :: tru0 initial true anomaly (deg) real(kind=wp) :: alt0 initial altitude for circular orbit (km) real(kind=wp) :: deadband_alt altitude below initial to trigger periapsis raise (km) real(kind=wp) :: inc_start inc/lan grid real(kind=wp) :: inc_stop real(kind=wp) :: inc_step real(kind=wp) :: lan_start real(kind=wp) :: lan_stop real(kind=wp) :: lan_step integer :: grav_n max grav degree integer :: grav_m max grav order character(len=:), allocatable :: ephemeris_file earth/moon/sun ephemeris file character(len=:), allocatable :: gravfile moon spherical harmonics gravity file real(kind=wp), dimension(:), allocatable :: x x array for plot (raan) real(kind=wp), dimension(:), allocatable :: y y array for plot (inc) real(kind=wp), dimension(:,:), allocatable :: z z array for plot (dv) real(kind=wp) :: inc0 initial inclination - IAU_MOON of date (deg) real(kind=wp) :: ran0 initial RAAN - IAU_MOON of date (deg) integer :: n_dvs number of DV maneuvers performed real(kind=wp) :: dv_total total DV (km/s) real(kind=wp), dimension(6) :: xf final state - inertial frame (km, km/s) integer :: i_inc inclination counter integer :: i_raan raan counter type(pyplot) :: plt pyplot handler integer :: istat pyplot status code character(len=10) :: istr for integer to string conversion character(len=10) :: dt_max_str character(len=10) :: deadband_alt_str type( segment ) :: seg the integrator for a ballistic moon-centered trajectory Subroutines subroutine read_config_file () Read the config file and populate the global variables. Arguments None subroutine size_arrays (xstart, xstop, xstep, ystart, ystop, ystep, x, y, z) Allocate the arrays. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xstart real(kind=wp), intent(in) :: xstop real(kind=wp), intent(in) :: xstep real(kind=wp), intent(in) :: ystart real(kind=wp), intent(in) :: ystop real(kind=wp), intent(in) :: ystep real(kind=wp), intent(out), dimension(:), allocatable :: x real(kind=wp), intent(out), dimension(:), allocatable :: y real(kind=wp), intent(out), dimension(:,:), allocatable :: z f(x,y) Source Code program main use altitude_maintenance_module , only : segment use fortran_astrodynamics_toolkit , only : km2m use pyplot_module , only : pyplot use iso_fortran_env , only : error_unit , output_unit , wp => real64 implicit none ! run variables, populated by the config file: real ( wp ) :: dt_max !! how long to propagate (days) real ( wp ) :: et0 !! initial ephemeris time (sec) !! (only matters if including Earth/Sun perturbations) real ( wp ) :: tru0 !! initial true anomaly (deg) real ( wp ) :: alt0 !! initial altitude for circular orbit (km) real ( wp ) :: deadband_alt !! altitude below initial to trigger periapsis raise (km) real ( wp ) :: inc_start !! inc/lan grid real ( wp ) :: inc_stop real ( wp ) :: inc_step real ( wp ) :: lan_start real ( wp ) :: lan_stop real ( wp ) :: lan_step integer :: grav_n !! max grav degree integer :: grav_m !! max grav order character ( len = :), allocatable :: ephemeris_file !! earth/moon/sun ephemeris file character ( len = :), allocatable :: gravfile !! moon spherical harmonics gravity file real ( wp ), dimension (:), allocatable :: x !! x array for plot (raan) real ( wp ), dimension (:), allocatable :: y !! y array for plot (inc) real ( wp ), dimension (:,:), allocatable :: z !! z array for plot (dv) real ( wp ) :: inc0 !! initial inclination - IAU_MOON of date (deg) real ( wp ) :: ran0 !! initial RAAN - IAU_MOON of date (deg) integer :: n_dvs !! number of DV maneuvers performed real ( wp ) :: dv_total !! total DV (km/s) real ( wp ), dimension ( 6 ) :: xf !! final state - inertial frame (km, km/s) integer :: i_inc !! inclination counter integer :: i_raan !! raan counter type ( pyplot ) :: plt !! pyplot handler integer :: istat !! pyplot status code character ( len = 10 ) :: istr !! for integer to string conversion character ( len = 10 ) :: dt_max_str character ( len = 10 ) :: deadband_alt_str type ( segment ) :: seg !! the integrator for a ballistic moon-centered trajectory ! populate the run variables: call read_config_file () ! initialize the segment: call seg % initialize_seg ( alt0 , deadband_alt , grav_n , grav_m , ephemeris_file , gravfile ) write ( dt_max_str , '(I10)' ) int ( dt_max ); dt_max_str = adjustl ( dt_max_str ) write ( deadband_alt_str , '(I10)' ) int ( deadband_alt ); deadband_alt_str = adjustl ( deadband_alt_str ) call plt % initialize ( grid = . true ., xlabel = 'LAN (deg)' ,& ylabel = 'Inc (deg)' , figsize = [ 20 , 10 ],& title = 'Lunar Orbit Maintenance $\\Delta v$ (m/s) : deadband = ' // & trim ( deadband_alt_str ) // ' km : dt = ' // trim ( dt_max_str ) // ' days' ,& real_fmt = '(E9.3)' ) ! initialize the indep arrays: call size_arrays ( lan_start , lan_stop , lan_step , inc_start , inc_stop , inc_step , x , y , z ) do i_inc = 1 , size ( y ) inc0 = y ( i_inc ) ! inclination do i_raan = 1 , size ( x ) ran0 = x ( i_raan ) ! right ascension of ascending node write ( output_unit , '(A)' ) '' write ( output_unit , '(A)' ) '==============' write ( output_unit , '(A,1X,F12.6,1X,F12.6)' ) 'inc, ran:' , inc0 , ran0 write ( output_unit , '(A)' ) '' call seg % altitude_maintenance ( et0 , inc0 , ran0 , tru0 , dt_max , n_dvs , dv_total , xf ) z ( i_raan , i_inc ) = dv_total * km2m ! delta-v in m/s write ( output_unit , '(A)' ) '' write ( output_unit , '(A,I5)' ) 'n_dvs    = ' , n_dvs write ( output_unit , '(A,F10.6)' ) 'dv_total = ' , dv_total write ( output_unit , '(A)' ) '==============' write ( output_unit , '(A)' ) '' end do end do ! create a contour plot for the delta-v: call plt % add_contour ( x , y , z , linestyle = '-' , & linewidth = 2 , filled = . true ., cmap = 'Blues' ,& colorbar = . true ., istat = istat ) call plt % savefig ( 'lom.png' , pyfile = 'lom.py' , istat = istat ) ! print some stats: write ( * , * ) '' write ( * , * ) '-- Stats --' do i_inc = 1 , size ( y ) write ( * , * ) '' write ( * , * ) 'max dv for inc ' , y ( i_inc ), ' : ' , maxval ( z (:, i_inc )), 'm/s' write ( * , * ) 'min dv for inc ' , y ( i_inc ), ' : ' , minval ( z (:, i_inc )), 'm/s' ! also make plots for each inc value: write ( istr , '(I10)' ) int ( y ( i_inc )) call plt % destroy () call plt % initialize ( grid = . true ., xlabel = 'LAN (deg)' ,& ylabel = '$\\Delta v$ (m/s)' , figsize = [ 10 , 10 ],& title = 'Lunar Orbit Maintenance : deadband = ' // & trim ( deadband_alt_str ) // ' km : dt = ' // & trim ( dt_max_str ) // ' days : Inc=' // trim ( adjustl ( istr )),& real_fmt = '(E9.3)' ) call plt % add_plot ( x , z (:, i_inc ), linestyle = 'b-' , label = 'dv' , istat = istat ) call plt % savefig ( 'lom_INC=' // trim ( adjustl ( istr )) // '.png' ,& pyfile = 'lom_INC=' // trim ( adjustl ( istr )) // '.py' , istat = istat ) end do contains !***************************************************************************************** !***************************************************************************************** !> !  Read the config file and populate the global variables. subroutine read_config_file () use argv_module , only : argv use json_module , only : json_file implicit none character ( len = :), allocatable :: filename type ( json_file ) :: json logical :: status_ok , found character ( len = :), allocatable :: error_msg filename = argv ( 1 ) ! get the first argument if ( filename == '' ) then error stop 'The first command line arg should be the config file name' else write ( * , '(A)' ) 'Reading config file: ' // trim ( filename ) call json % initialize () ! no optional args for now call json % load ( filename ) if ( json % failed ()) then call json % check_for_errors ( error_msg = error_msg ) error stop error_msg else ! populate the run variables: call json % get ( 'dt_max' , dt_max , found ); if (. not . found ) error stop 'dt_max not found in config file.' call json % get ( 'et0' , et0 , found ); if (. not . found ) error stop 'et0 not found in config file.' call json % get ( 'tru0' , tru0 , found ); if (. not . found ) error stop 'tru0 not found in config file.' call json % get ( 'alt0' , alt0 , found ); if (. not . found ) error stop 'alt0 not found in config file.' call json % get ( 'deadband_alt' , deadband_alt , found ); if (. not . found ) error stop 'deadband_alt not found in config file.' call json % get ( 'inc_start' , inc_start , found ); if (. not . found ) error stop 'inc_start not found in config file.' call json % get ( 'inc_stop' , inc_stop , found ); if (. not . found ) error stop 'inc_stop not found in config file.' call json % get ( 'inc_step' , inc_step , found ); if (. not . found ) error stop 'inc_step not found in config file.' call json % get ( 'lan_start' , lan_start , found ); if (. not . found ) error stop 'lan_start not found in config file.' call json % get ( 'lan_stop' , lan_stop , found ); if (. not . found ) error stop 'lan_stop not found in config file.' call json % get ( 'lan_step' , lan_step , found ); if (. not . found ) error stop 'lan_step not found in config file.' call json % get ( 'grav_n' , grav_n , found ); if (. not . found ) error stop 'grav_n not found in config file.' call json % get ( 'grav_m' , grav_m , found ); if (. not . found ) error stop 'grav_m not found in config file.' call json % get ( 'ephemeris_file' , ephemeris_file , found ) if (. not . found ) error stop 'ephemeris_file not found in config file.' call json % get ( 'gravfile' , gravfile , found ) if (. not . found ) error stop 'gravfile not found in config file.' end if call json % destroy () end if end subroutine read_config_file !***************************************************************************************** !***************************************************************************************** !> !  Allocate the arrays. subroutine size_arrays ( xstart , xstop , xstep , ystart , ystop , ystep , x , y , z ) implicit none real ( wp ), intent ( in ) :: xstart , xstop , xstep , ystart , ystop , ystep real ( wp ), dimension (:), allocatable , intent ( out ) :: x , y real ( wp ), dimension (:,:), allocatable , intent ( out ) :: z !! f(x,y) integer :: i , j , nx , ny real ( wp ) :: tmp nx = 1 tmp = xstart x = [ tmp ] do tmp = tmp + xstep if ( tmp > xstop ) exit nx = nx + 1 x = [ x , tmp ] end do ny = 1 tmp = ystart y = [ tmp ] do tmp = tmp + ystep if ( tmp > ystop ) exit ny = ny + 1 y = [ y , tmp ] end do allocate ( z ( nx , ny )) z = 0.0_wp end subroutine size_arrays !***************************************************************************************** !***************************************************************************************** end program main","tags":"","loc":"program/main.html"}]}